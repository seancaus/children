// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HALL_SHARE_HALL_H_
#define FLATBUFFERS_GENERATED_HALL_SHARE_HALL_H_

#include "flatbuffers/flatbuffers.h"

namespace share {
    namespace hall {

        struct User;

        struct LoginRequest;

        struct LoginReply;

        struct Message;

        enum Any {
            Any_NONE = 0,
            Any_LoginRequest = 1,
            Any_LoginReply = 2,
            Any_MIN = Any_NONE,
            Any_MAX = Any_LoginReply
        };

        inline Any (&EnumValuesAny())[3] {
                static Any values[] = {
                  Any_NONE,
                          Any_LoginRequest,
                          Any_LoginReply
                };
                return values;
        }

        inline const char **EnumNamesAny() {
          static const char *names[] = {
                  "NONE",
                  "LoginRequest",
                  "LoginReply",
                  nullptr
          };
          return names;
        }

        inline const char *EnumNameAny(Any e) {
          const size_t index = static_cast<int>(e);
          return EnumNamesAny()[index];
        }

        template<typename T> struct AnyTraits {
            static const Any enum_value = Any_NONE;
        };

        template<> struct AnyTraits<LoginRequest> {
            static const Any enum_value = Any_LoginRequest;
        };

        template<> struct AnyTraits<LoginReply> {
            static const Any enum_value = Any_LoginReply;
        };

        bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type);
        bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

        struct User FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
            enum {
                VT_CA = 4,
                VT_UID = 6,
                VT_NICKNAME = 8
            };
            const flatbuffers::String *ca() const {
              return GetPointer<const flatbuffers::String *>(VT_CA);
            }
            const flatbuffers::String *uid() const {
              return GetPointer<const flatbuffers::String *>(VT_UID);
            }
            const flatbuffers::String *nickName() const {
              return GetPointer<const flatbuffers::String *>(VT_NICKNAME);
            }
            bool Verify(flatbuffers::Verifier &verifier) const {
              return VerifyTableStart(verifier) &&
                     VerifyOffset(verifier, VT_CA) &&
                     verifier.Verify(ca()) &&
                     VerifyOffset(verifier, VT_UID) &&
                     verifier.Verify(uid()) &&
                     VerifyOffset(verifier, VT_NICKNAME) &&
                     verifier.Verify(nickName()) &&
                     verifier.EndTable();
            }
        };

        struct UserBuilder {
            flatbuffers::FlatBufferBuilder &fbb_;
            flatbuffers::uoffset_t start_;
            void add_ca(flatbuffers::Offset<flatbuffers::String> ca) {
              fbb_.AddOffset(User::VT_CA, ca);
            }
            void add_uid(flatbuffers::Offset<flatbuffers::String> uid) {
              fbb_.AddOffset(User::VT_UID, uid);
            }
            void add_nickName(flatbuffers::Offset<flatbuffers::String> nickName) {
              fbb_.AddOffset(User::VT_NICKNAME, nickName);
            }
            explicit UserBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                    : fbb_(_fbb) {
              start_ = fbb_.StartTable();
            }
            UserBuilder &operator=(const UserBuilder &);
            flatbuffers::Offset<User> Finish() {
              const auto end = fbb_.EndTable(start_);
              auto o = flatbuffers::Offset<User>(end);
              return o;
            }
        };

        inline flatbuffers::Offset<User> CreateUser(
                flatbuffers::FlatBufferBuilder &_fbb,
                flatbuffers::Offset<flatbuffers::String> ca = 0,
                flatbuffers::Offset<flatbuffers::String> uid = 0,
                flatbuffers::Offset<flatbuffers::String> nickName = 0) {
          UserBuilder builder_(_fbb);
          builder_.add_nickName(nickName);
          builder_.add_uid(uid);
          builder_.add_ca(ca);
          return builder_.Finish();
        }

        inline flatbuffers::Offset<User> CreateUserDirect(
                flatbuffers::FlatBufferBuilder &_fbb,
                const char *ca = nullptr,
                const char *uid = nullptr,
                const char *nickName = nullptr) {
          return share::hall::CreateUser(
                  _fbb,
                  ca ? _fbb.CreateString(ca) : 0,
                  uid ? _fbb.CreateString(uid) : 0,
                  nickName ? _fbb.CreateString(nickName) : 0);
        }

        struct LoginRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
            enum {
                VT_CA = 4
            };
            const flatbuffers::String *ca() const {
              return GetPointer<const flatbuffers::String *>(VT_CA);
            }
            bool Verify(flatbuffers::Verifier &verifier) const {
              return VerifyTableStart(verifier) &&
                     VerifyOffset(verifier, VT_CA) &&
                     verifier.Verify(ca()) &&
                     verifier.EndTable();
            }
        };

        struct LoginRequestBuilder {
            flatbuffers::FlatBufferBuilder &fbb_;
            flatbuffers::uoffset_t start_;
            void add_ca(flatbuffers::Offset<flatbuffers::String> ca) {
              fbb_.AddOffset(LoginRequest::VT_CA, ca);
            }
            explicit LoginRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                    : fbb_(_fbb) {
              start_ = fbb_.StartTable();
            }
            LoginRequestBuilder &operator=(const LoginRequestBuilder &);
            flatbuffers::Offset<LoginRequest> Finish() {
              const auto end = fbb_.EndTable(start_);
              auto o = flatbuffers::Offset<LoginRequest>(end);
              return o;
            }
        };

        inline flatbuffers::Offset<LoginRequest> CreateLoginRequest(
                flatbuffers::FlatBufferBuilder &_fbb,
                flatbuffers::Offset<flatbuffers::String> ca = 0) {
          LoginRequestBuilder builder_(_fbb);
          builder_.add_ca(ca);
          return builder_.Finish();
        }

        inline flatbuffers::Offset<LoginRequest> CreateLoginRequestDirect(
                flatbuffers::FlatBufferBuilder &_fbb,
                const char *ca = nullptr) {
          return share::hall::CreateLoginRequest(
                  _fbb,
                  ca ? _fbb.CreateString(ca) : 0);
        }

        struct LoginReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
            enum {
                VT_PLAYER = 4
            };
            const User *player() const {
              return GetPointer<const User *>(VT_PLAYER);
            }
            bool Verify(flatbuffers::Verifier &verifier) const {
              return VerifyTableStart(verifier) &&
                     VerifyOffset(verifier, VT_PLAYER) &&
                     verifier.VerifyTable(player()) &&
                     verifier.EndTable();
            }
        };

        struct LoginReplyBuilder {
            flatbuffers::FlatBufferBuilder &fbb_;
            flatbuffers::uoffset_t start_;
            void add_player(flatbuffers::Offset<User> player) {
              fbb_.AddOffset(LoginReply::VT_PLAYER, player);
            }
            explicit LoginReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                    : fbb_(_fbb) {
              start_ = fbb_.StartTable();
            }
            LoginReplyBuilder &operator=(const LoginReplyBuilder &);
            flatbuffers::Offset<LoginReply> Finish() {
              const auto end = fbb_.EndTable(start_);
              auto o = flatbuffers::Offset<LoginReply>(end);
              return o;
            }
        };

        inline flatbuffers::Offset<LoginReply> CreateLoginReply(
                flatbuffers::FlatBufferBuilder &_fbb,
                flatbuffers::Offset<User> player = 0) {
          LoginReplyBuilder builder_(_fbb);
          builder_.add_player(player);
          return builder_.Finish();
        }

        struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
            enum {
                VT_OBJECT_TYPE = 4,
                VT_OBJECT = 6
            };
            Any object_type() const {
              return static_cast<Any>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
            }
            const void *object() const {
              return GetPointer<const void *>(VT_OBJECT);
            }
            template<typename T> const T *object_as() const;
            const LoginRequest *object_as_LoginRequest() const {
              return object_type() == Any_LoginRequest ? static_cast<const LoginRequest *>(object()) : nullptr;
            }
            const LoginReply *object_as_LoginReply() const {
              return object_type() == Any_LoginReply ? static_cast<const LoginReply *>(object()) : nullptr;
            }
            bool Verify(flatbuffers::Verifier &verifier) const {
              return VerifyTableStart(verifier) &&
                     VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
                     VerifyOffset(verifier, VT_OBJECT) &&
                     VerifyAny(verifier, object(), object_type()) &&
                     verifier.EndTable();
            }
        };

        template<> inline const LoginRequest *Message::object_as<LoginRequest>() const {
          return object_as_LoginRequest();
        }

        template<> inline const LoginReply *Message::object_as<LoginReply>() const {
          return object_as_LoginReply();
        }

        struct MessageBuilder {
            flatbuffers::FlatBufferBuilder &fbb_;
            flatbuffers::uoffset_t start_;
            void add_object_type(Any object_type) {
              fbb_.AddElement<uint8_t>(Message::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
            }
            void add_object(flatbuffers::Offset<void> object) {
              fbb_.AddOffset(Message::VT_OBJECT, object);
            }
            explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                    : fbb_(_fbb) {
              start_ = fbb_.StartTable();
            }
            MessageBuilder &operator=(const MessageBuilder &);
            flatbuffers::Offset<Message> Finish() {
              const auto end = fbb_.EndTable(start_);
              auto o = flatbuffers::Offset<Message>(end);
              return o;
            }
        };

        inline flatbuffers::Offset<Message> CreateMessage(
                flatbuffers::FlatBufferBuilder &_fbb,
                Any object_type = Any_NONE,
                flatbuffers::Offset<void> object = 0) {
          MessageBuilder builder_(_fbb);
          builder_.add_object(object);
          builder_.add_object_type(object_type);
          return builder_.Finish();
        }

        inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type) {
          switch (type) {
            case Any_NONE: {
              return true;
            }
            case Any_LoginRequest: {
              auto ptr = reinterpret_cast<const LoginRequest *>(obj);
              return verifier.VerifyTable(ptr);
            }
            case Any_LoginReply: {
              auto ptr = reinterpret_cast<const LoginReply *>(obj);
              return verifier.VerifyTable(ptr);
            }
            default: return false;
          }
        }

        inline bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
          if (values->size() != types->size()) return false;
          for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
            if (!VerifyAny(
                    verifier,  values->Get(i), types->GetEnum<Any>(i))) {
              return false;
            }
          }
          return true;
        }

        inline const share::hall::Message *GetMessage(const void *buf) {
          return flatbuffers::GetRoot<share::hall::Message>(buf);
        }

        inline bool VerifyMessageBuffer(
                flatbuffers::Verifier &verifier) {
          return verifier.VerifyBuffer<share::hall::Message>(nullptr);
        }

        inline const char *MessageExtension() {
          return "mon";
        }

        inline void FinishMessageBuffer(
                flatbuffers::FlatBufferBuilder &fbb,
                flatbuffers::Offset<share::hall::Message> root) {
          fbb.Finish(root);
        }

    }  // namespace hall
}  // namespace share

#endif  // FLATBUFFERS_GENERATED_HALL_SHARE_HALL_H_
